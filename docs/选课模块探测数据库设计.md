# 选课历史众包系统 - 设计文档

## 1. 项目概述

### 1.1 项目目标

本项目旨在解决高校教务系统选课信息不透明、时效性短的问题。通过众包（Crowdsourcing）的方式，收集并汇总每位学生的课程搜索结果，构建一个可供查询的选课历史数据库。最终目标是为后来的学生提供参考，帮助他们预测心仪课程可能出现的选课模块、轮次等信息，从而做出更合理的选课规划。

### 1.2 设计原则

- **数据完整性与准确性**：设计必须保证数据的唯一性和准确性，避免冗余和矛盾的数据录入。这是系统的核心基石。
- **用户匿名性**：严格遵守匿名原则，收集的数据在任何情况下都不能用于精确识别或追溯到任何个体学生。
- **高内聚、低耦合**：系统各模块（如数据模型、业务逻辑）应清晰分离，易于理解、维护和未来扩展。
- **健壮性与可靠性**：系统设计应能抵御因上游（教务系统）数据格式微小变化（如选课标题变更）而导致的逻辑错误。

## 2. 数据库设计

为实现上述原则，我们采用关系型数据库模型（以 SQLite 为蓝本），并设计两张核心数据表，以实现数据的规范化和高效管理。

### 2.1 数据表 1: `selection_batches` (选课批次表)

**用途**：此表作为一张"字典表"或"元数据表"。其唯一作用是记录并映射每一个独立的选课事件（批次）。它将教务系统生成的、稳定可靠的`批次ID`与人类可读的、但可能发生变化的`批次标题`关联起来。

**表结构设计**：

| 字段名        | 数据类型 | 约束                      | 描述                                                                                                   |
| :------------ | :------- | :------------------------ | :----------------------------------------------------------------------------------------------------- |
| `batch_id`    | TEXT     | `PRIMARY KEY`, `NOT NULL` | **选课批次 ID**。从教务系统 URL 中提取的唯一标识符。作为此表的主键，是系统识别不同选课事件的唯一依据。 |
| `batch_title` | TEXT     | `NOT NULL`                | **选课批次标题**。教务系统显示的完整标题，如"2024 级 2025-2026-1 计算机学院专业选课"，用于向用户展示。 |
| `created_at`  | DATETIME | `NOT NULL`                | **创建时间**。该选课批次首次被系统记录的时间。                                                         |

### 2.2 数据表 2: `course_sightings` (课程观测数据表)

**用途**：这是系统的核心数据表，用于存储每一条被众包收集到的、独一无二的课程观测记录。

**表结构设计**：

| 字段名               | 数据类型 | 约束                        | 描述                                                                                             |
| :------------------- | :------- | :-------------------------- | :----------------------------------------------------------------------------------------------- |
| `id`                 | INTEGER  | `PRIMARY KEY AUTOINCREMENT` | **自增 ID**。无业务含义，仅作为每一行记录的唯一标识符。                                          |
| `course_code`        | TEXT     | `NOT NULL`                  | **课程号**。课程的官方唯一代码。                                                                 |
| `course_name`        | TEXT     | `NOT NULL`                  | **课程名称**。                                                                                   |
| `instructor_name`    | TEXT     | `NOT NULL`                  | **授课老师**。                                                                                   |
| `module_name`        | TEXT     | `NOT NULL`                  | **所属模块**。本系统的核心目标数据。                                                             |
| `student_grade`      | TEXT     | `NOT NULL`                  | **查询者年级**。用于限定数据的适用人群。                                                         |
| `student_college`    | TEXT     | `NOT NULL`                  | **查询者学院**。                                                                                 |
| `student_major`      | TEXT     | `NOT NULL`                  | **查询者专业**。                                                                                 |
| `batch_id_fk`        | TEXT     | `NOT NULL`, `FOREIGN KEY`   | **外键：选课批次 ID**。关联到 `selection_batches`表的 `batch_id`，表明这条记录属于哪个选课事件。 |
| `confirmation_count` | INTEGER  | `NOT NULL`, `DEFAULT 1`     | **数据确认次数**。代表这条完全相同的记录被多少用户提交过，是数据可信度的体现。                   |
| `created_at`         | DATETIME | `NOT NULL`                  | **首次记录时间**。                                                                               |
| `updated_at`         | DATETIME | `NOT NULL`                  | **最近确认时间**。每次 `confirmation_count` 增加时更新此字段。                                   |

### 2.3 核心约束设计：联合唯一约束 (Unique Combination)

为保证 `course_sightings` 表中没有重复数据，需在以下七个字段的组合上建立一个**联合唯一约束**：

- `course_code`
- `instructor_name`
- `module_name`
- `student_grade`
- `student_college`
- `student_major`
- `batch_id_fk`

**设计理由**：这七个字段的组合完整地定义了一个"独一无二的事件"。只有当这七个值完全相同时，我们才视其为一条重复的观测记录。任何一个值的不同都意味着这是一条新的、需要独立记录的数据。

## 3. 核心业务逻辑流程

### 3.1 数据上报（写入）逻辑

当后端接收到一条来自用户客户端的上报数据时，应遵循以下原子性操作流程：

1. **数据提取**：从上报数据中解析出所有必要字段，包括课程信息、查询者信息、`batch_id` 和 `batch_title`。

2. **数据校验**：检查所有必填字段是否存在且格式基本正确。

3. **处理选课批次 (`selection_batches` 表)**：

   - 根据上报的 `batch_id` 查询 `selection_batches` 表。
   - **若记录不存在**：向表中插入一条新的记录 `(batch_id, batch_title)`。
   - **若记录已存在**：不做任何操作。此步骤保证了每个选课批次只被记录一次。

4. **处理课程观测数据 (`course_sightings` 表)**：

   - 执行一个"**存在即更新，不存在即插入 (Upsert)**"的操作。
   - **判断依据**：使用上述定义的"联合唯一约束"中的七个字段作为判断条件。
   - **若记录不存在**：向 `course_sightings` 表插入一条全新的记录，`confirmation_count` 默认值为 1。
   - **若记录已存在**：不插入新记录，而是将该记录的 `confirmation_count` 字段值加 1，并更新 `updated_at` 字段为当前时间。

5. **返回结果**：向上报客户端返回操作成功的消息。

### 3.2 数据查询（读取）逻辑

当学生用户在前端查询课程历史信息时：

1. **接收请求**：后端接收来自用户的查询请求，通常包含课程关键词（代码或名称）以及该用户自身的上下文信息（年级、学院、专业）。

2. **查询数据库**：

   - 主要在 `course_sightings` 表中进行查询，使用课程关键词进行模糊匹配。
   - 使用用户的年级、学院、专业信息对结果进行初步过滤，以展示最相关的历史数据。
   - 通过 `batch_id_fk` 关联查询 `selection_batches` 表，获取可读的 `batch_title`。

3. **聚合与排序**：

   - 对查询结果进行处理，将同一门课程（由`course_code` 和 `instructor_name` 标识）在不同批次、不同模块的出现情况进行聚合。
   - 结果应优先按 `confirmation_count`（确认次数）降序排列，再按 `updated_at`（最近出现时间）降序排列，将最可信、最新的信息展示给用户。

4. **返回数据**：将结构化、清晰易读的查询结果以 JSON 格式返回给前端进行展示。
